<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finite State Transducers Fundamentals | ML Fundamentals</title>
    <meta name="description" content="Introduction to Finite State Machines and Transducers: definitions, examples, composition, and when to use FSTs in practice.">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&family=Playfair+Display:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\\\[', right: '\\\\]', display: true}, {left: '\\\\(', right: '\\\\)', display: false}], throwOnError: false});"></script>

    <!-- Styles -->
    <link rel="stylesheet" href="../../../css/main.css">
    <link rel="stylesheet" href="../../../css/components.css">
    <link rel="stylesheet" href="../../../css/sidebar.css">

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x221E;</text></svg>">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar" id="navbar">
        <div class="nav-container">
            <a href="../../../index.html" class="nav-logo">
                <span class="logo-symbol">&nabla;</span>
                <span class="logo-text">ML Fundamentals</span>
            </a>

            <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">
                <span></span>
                <span></span>
                <span></span>
            </button>

            <div class="nav-menu" id="navMenu">
                <div class="nav-links">
                    <a href="../../../tutorials/ml/index.html" class="nav-link active">Machine Learning</a>
                    <a href="../../../tutorials/linear-algebra/index.html" class="nav-link">Linear Algebra</a>
                    <a href="../../../tutorials/calculus/index.html" class="nav-link">Calculus</a>
                    <a href="../../../tutorials/physics/index.html" class="nav-link">Physics</a>
                    <a href="../../../index.html#philosophy" class="nav-link">Philosophy</a>
                    <a href="../../../index.html#roadmap" class="nav-link">Roadmap</a>
                    <a href="https://github.com/ml-entropy/ml-entropy.github.io" class="nav-link" target="_blank">GitHub</a>
                </div>

                <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
                    <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
                    </svg>
                    <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>
    </nav>

    <!-- Tutorial Header -->
    <header class="tutorial-content-header">
        <div class="container">
            <nav class="breadcrumb">
                <a href="../../../index.html">Home</a>
                <span class="breadcrumb-separator">&rarr;</span>
                <a href="../index.html">Machine Learning</a>
                <span class="breadcrumb-separator">&rarr;</span>
                <span>FST Fundamentals</span>
            </nav>

            <div class="tutorial-tabs">
                <a href="#theory" class="tutorial-tab active">Theory</a>
                <a href="#code" class="tutorial-tab">Code</a>
                <a href="#exercises" class="tutorial-tab">Exercises</a>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="tutorial-wrapper">

        <!-- Sidebar Navigation -->
        <!-- Sidebar Navigation -->
        <!-- Sidebar Navigation -->
        <aside class="tutorial-sidebar">
            <div class="sidebar-section">
                <h3 class="sidebar-section-title">Machine Learning</h3>
                <nav class="sidebar-nav">
                        <a href="../00-probability/index.html" class="sidebar-link">00. Probability Foundations</a>
                    <a href="../04-logarithms/index.html" class="sidebar-link">01. Why Logarithms?</a>
                    <a href="../05-combinatorics/index.html" class="sidebar-link">02. Combinatorics</a>
                    <a href="../03-distributions/index.html" class="sidebar-link">03. Normal Distributions</a>
                    <a href="../01-entropy/index.html" class="sidebar-link">04. Entropy Fundamentals</a>
                    <a href="../02-cross-entropy/index.html" class="sidebar-link">05. Cross-Entropy</a>
                    <a href="../02-kl-divergence/index.html" class="sidebar-link">06. KL Divergence</a>
                    <a href="../14-entropy-connections/index.html" class="sidebar-link">07. Entropy Connections</a>
                    <a href="../06-backpropagation/index.html" class="sidebar-link">08. Backpropagation</a>
                    <a href="../07-regularization/index.html" class="sidebar-link">09. Regularization</a>
                    <a href="../08-batch-normalization/index.html" class="sidebar-link">10. Batch Normalization</a>
                    <a href="../09-learning-rate/index.html" class="sidebar-link">11. Learning Rate</a>
                    <a href="../10-cnn/index.html" class="sidebar-link">12. CNNs</a>
                    <a href="../11-rnn/index.html" class="sidebar-link">13. RNNs</a>
                    <a href="../15-autoencoder/index.html" class="sidebar-link">14. Autoencoders</a>
                    <a href="../13-variational-inference/index.html" class="sidebar-link">15. Variational Inference</a>
                    <a href="../12-vae/index.html" class="sidebar-link">16. VAE</a>
                    <a href="../16-inductive-bias/index.html" class="sidebar-link">17. Inductive Bias</a>
                    <a href="../17-architectural-biases/index.html" class="sidebar-link">18. Architectural Biases</a>
                    <a href="../18-designing-biases/index.html" class="sidebar-link">19. Designing Biases</a>
                    <a href="../19-fst-fundamentals/index.html" class="sidebar-link active">20. FST Fundamentals</a>
                    <a href="../20-weighted-fsts/index.html" class="sidebar-link">21. Weighted FSTs</a>
                    <a href="../21-fst-libraries/index.html" class="sidebar-link">22. FST Libraries</a>
                    <a href="../22-fst-applications/index.html" class="sidebar-link">23. FST Applications</a>
                    <a href="../23-neural-symbolic/index.html" class="sidebar-link">24. Neural-Symbolic Hybrids</a>
                </nav>
            </div>
            
            <div class="sidebar-section" style="margin-top: 2rem;">
                <h3 class="sidebar-section-title">Related Subjects</h3>
                <nav class="sidebar-nav">
                        <a href="../../linear-algebra/index.html" class="sidebar-link">Linear Algebra</a>
                    <a href="../../calculus/index.html" class="sidebar-link">Calculus</a>
                    <a href="../../physics/index.html" class="sidebar-link">Physics</a>
                </nav>
            </div>
        </aside>

        <!-- Main Article -->
        <main class="tutorial-main">

            <!-- ==================== THEORY TAB ==================== -->
            <article class="article-content" id="theory">

                <!-- Section 1: What Are FSTs -->
                <h2 id="what-are-fsts">What Are Finite State Transducers?</h2>

                <p>
                    Imagine you need to convert dates from "02/16/2026" to "February 16, 2026", or transform "Dr." into "Doctor", or convert a phoneme sequence into written text. These are all <strong>deterministic sequence transformations</strong> &mdash; they take an input sequence and produce an output sequence according to fixed rules.
                </p>

                <p>
                    A <strong>Finite State Transducer</strong> (FST) is a computational model that performs exactly this kind of transformation. It reads input symbols one at a time, transitions between internal states, and produces output symbols along the way. FSTs are the workhorse of rule-based NLP, speech processing, and text normalization.
                </p>

                <div class="definition-box">
                    <div class="box-title">Finite State Machine (FSM) vs Finite State Transducer (FST)</div>
                    <p>
                        A <strong>Finite State Machine</strong> (also called a Finite Automaton) is a <em>recognizer</em>: it reads input and decides whether to accept or reject it. It has no output tape.
                    </p>
                    <p style="margin-bottom: 0;">
                        A <strong>Finite State Transducer</strong> is a <em>transformer</em>: it reads input and produces output. Each transition consumes an input symbol and emits an output symbol. An FST defines a <strong>relation</strong> between input and output strings.
                    </p>
                </div>

                <p>
                    Think of an FSM as a yes/no question ("Is this a valid email?") and an FST as a conversion function ("Convert this email to lowercase"). Both use the same finite-state machinery, but FSTs have an extra output tape.
                </p>

                <p><strong>Everyday examples of FST-like transformations:</strong></p>
                <ul>
                    <li><strong>Lowercase to uppercase:</strong> a &rarr; A, b &rarr; B, c &rarr; C, ...</li>
                    <li><strong>Phoneme to grapheme:</strong> /k ae t/ &rarr; "cat"</li>
                    <li><strong>Number to words:</strong> "42" &rarr; "forty-two"</li>
                    <li><strong>Date normalization:</strong> "2/16/26" &rarr; "February 16, 2026"</li>
                </ul>

                <!-- Section 2: Formal Definition -->
                <h2 id="formal-definition">Formal Definition</h2>

                <p>
                    An FST is defined mathematically as a tuple of components. This formal definition gives us precise language for reasoning about transducers and proving properties about them.
                </p>

                <div class="definition-box">
                    <div class="box-title">Finite State Transducer (Formal Definition)</div>
                    <p>An FST is a 6-tuple $T = (Q, \Sigma, \Gamma, \delta, q_0, F)$ where:</p>
                    <ul style="margin-bottom: 0;">
                        <li>$Q$ is a finite set of <strong>states</strong></li>
                        <li>$\Sigma$ is a finite <strong>input alphabet</strong></li>
                        <li>$\Gamma$ is a finite <strong>output alphabet</strong></li>
                        <li>$\delta \subseteq Q \times (\Sigma \cup \{\varepsilon\}) \times (\Gamma \cup \{\varepsilon\}) \times Q$ is the <strong>transition relation</strong></li>
                        <li>$q_0 \in Q$ is the <strong>start state</strong></li>
                        <li>$F \subseteq Q$ is the set of <strong>final (accepting) states</strong></li>
                    </ul>
                </div>

                <p>
                    Each transition $(q, a, b, q')$ means: "In state $q$, reading input symbol $a$, output symbol $b$ and move to state $q'$." The special symbol $\varepsilon$ (epsilon) represents the empty string &mdash; a transition can consume no input or produce no output.
                </p>

                <div class="math-derivation">
                    <div class="math-derivation-title">Reading a Transition</div>

                    <div class="math-step">
                        <div class="math-step-number">1</div>
                        <div class="math-step-content">
                            <p>A transition $(q_1, \texttt{a}, \texttt{A}, q_2)$ means:</p>
                            <div class="math-block">
                                $$\text{State } q_1 \xrightarrow{\texttt{a} : \texttt{A}} q_2$$
                            </div>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">2</div>
                        <div class="math-step-content">
                            <p>Read: "In state $q_1$, on input <code>a</code>, output <code>A</code> and go to state $q_2$."</p>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">3</div>
                        <div class="math-step-content">
                            <p>The notation $a : b$ on a transition arrow denotes input:output.</p>
                        </div>
                    </div>
                </div>

                <p>
                    A <strong>path</strong> through an FST is a sequence of transitions from the start state to a final state. The input of the path is the concatenation of all input symbols, and the output is the concatenation of all output symbols. An FST defines a relation: the set of all (input, output) pairs that correspond to valid paths.
                </p>

                <!-- Section 3: Simple Examples -->
                <h2 id="simple-examples">Simple FST Examples</h2>

                <p>
                    Let's trace through several concrete FSTs to build intuition. The best way to understand FSTs is to follow the state transitions step by step.
                </p>

                <p><strong>Example 1: Roman Numeral Parser (simplified)</strong></p>
                <p>
                    Consider an FST that converts simple Roman numerals (I, II, III, IV, V) to decimal digits. The key challenge: subtractive notation ("IV" = 4) requires <em>lookahead</em> &mdash; when we see 'I', we can't immediately output '1' because the next symbol might be 'V' (making it '4').
                </p>

                <div class="note-box">
                    <div class="box-title">Lookahead via State Encoding</div>
                    <p style="margin-bottom: 0;">
                        FSTs handle lookahead by encoding "what we've seen but not yet processed" into the state. State $q_I$ means "we've consumed an 'I' but haven't decided what to output yet." This is a fundamental FST design pattern: <strong>delay output until you have enough context</strong>.
                    </p>
                </div>

                <p>Full transition table:</p>
                <table style="width: 100%; border-collapse: collapse; margin: 1.5rem 0;">
                    <thead>
                        <tr style="border-bottom: 2px solid var(--color-border);">
                            <th style="text-align: left; padding: 0.75rem;">From State</th>
                            <th style="text-align: left; padding: 0.75rem;">Input</th>
                            <th style="text-align: left; padding: 0.75rem;">Output</th>
                            <th style="text-align: left; padding: 0.75rem;">To State</th>
                            <th style="text-align: left; padding: 0.75rem;">Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">$q_0$</td>
                            <td style="padding: 0.75rem;">V</td>
                            <td style="padding: 0.75rem;">5</td>
                            <td style="padding: 0.75rem;">$q_F$</td>
                            <td style="padding: 0.75rem;">"V" &rarr; 5</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">$q_0$</td>
                            <td style="padding: 0.75rem;">I</td>
                            <td style="padding: 0.75rem;">$\varepsilon$</td>
                            <td style="padding: 0.75rem;">$q_I$</td>
                            <td style="padding: 0.75rem;">Buffer 'I', wait for next</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">$q_I$</td>
                            <td style="padding: 0.75rem;">V</td>
                            <td style="padding: 0.75rem;">4</td>
                            <td style="padding: 0.75rem;">$q_F$</td>
                            <td style="padding: 0.75rem;">"IV" &rarr; 4 (subtractive)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">$q_I$</td>
                            <td style="padding: 0.75rem;">I</td>
                            <td style="padding: 0.75rem;">$\varepsilon$</td>
                            <td style="padding: 0.75rem;">$q_{II}$</td>
                            <td style="padding: 0.75rem;">"II" so far, keep buffering</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">$q_I$</td>
                            <td style="padding: 0.75rem;">$\varepsilon$</td>
                            <td style="padding: 0.75rem;">1</td>
                            <td style="padding: 0.75rem;">$q_F$</td>
                            <td style="padding: 0.75rem;">End of input: just "I" &rarr; 1</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">$q_{II}$</td>
                            <td style="padding: 0.75rem;">I</td>
                            <td style="padding: 0.75rem;">3</td>
                            <td style="padding: 0.75rem;">$q_F$</td>
                            <td style="padding: 0.75rem;">"III" &rarr; 3</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem;">$q_{II}$</td>
                            <td style="padding: 0.75rem;">$\varepsilon$</td>
                            <td style="padding: 0.75rem;">2</td>
                            <td style="padding: 0.75rem;">$q_F$</td>
                            <td style="padding: 0.75rem;">End of input: "II" &rarr; 2</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>Trace 1:</strong> Input "IV"</p>
                <ol>
                    <li>Start in $q_0$. Read 'I', output $\varepsilon$, go to $q_I$. &nbsp; <em>(Buffer: we saw I but don't know what comes next)</em></li>
                    <li>In $q_I$. Read 'V', output '4', go to $q_F$. &nbsp; <em>(IV = subtractive notation &rarr; 4)</em></li>
                    <li>In $q_F$ (final state). <strong>Output: "4"</strong>.</li>
                </ol>

                <p><strong>Trace 2:</strong> Input "III"</p>
                <ol>
                    <li>$q_0$: Read 'I', output $\varepsilon$, go to $q_I$.</li>
                    <li>$q_I$: Read 'I', output $\varepsilon$, go to $q_{II}$.</li>
                    <li>$q_{II}$: Read 'I', output '3', go to $q_F$.</li>
                    <li>In $q_F$ (final state). <strong>Output: "3"</strong>.</li>
                </ol>

                <p><strong>Example 2: Number-to-Word Converter (single digits)</strong></p>
                <p>
                    A simple FST with one state that maps digit characters to words. This is a <strong>single-state, deterministic FST</strong> &mdash; the simplest possible transducer structure:
                </p>
                <ul>
                    <li>$q_0 \xrightarrow{\texttt{0}:\texttt{zero}} q_0$, $q_0 \xrightarrow{\texttt{1}:\texttt{one}} q_0$, $q_0 \xrightarrow{\texttt{2}:\texttt{two}} q_0$, $q_0 \xrightarrow{\texttt{3}:\texttt{three}} q_0$, ...</li>
                </ul>
                <p>
                    <strong>Trace:</strong> Input "3" &rarr; state $q_0$, read '3', output "three", stay in $q_0$. Output: "three".
                </p>
                <p>
                    This FST processes multi-digit inputs too: "42" &rarr; "four" + "two" = "fourtwo". For proper English ("forty-two"), we'd need a multi-state FST that handles tens and ones together &mdash; a good exercise for the reader.
                </p>

                <p><strong>Example 3: Date Format Normalizer (MM/DD &rarr; DD.MM)</strong></p>
                <p>
                    Converting "MM/DD" to "DD.MM" requires an FST that <strong>buffers</strong> the month digits, reads past the slash, then outputs the day followed by the month. This demonstrates that FST output can be reordered relative to input.
                </p>

                <div class="math-derivation">
                    <div class="math-derivation-title">Trace: Input "02/16" &rarr; Output "16.02"</div>

                    <div class="math-step">
                        <div class="math-step-number">1</div>
                        <div class="math-step-content">
                            <p>$q_0$: Read '0', output $\varepsilon$, go to $q_{M_0}$. &nbsp; <em>(State encodes first month digit '0')</em></p>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">2</div>
                        <div class="math-step-content">
                            <p>$q_{M_0}$: Read '2', output $\varepsilon$, go to $q_{M_{02}}$. &nbsp; <em>(State encodes full month "02")</em></p>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">3</div>
                        <div class="math-step-content">
                            <p>$q_{M_{02}}$: Read '/', output $\varepsilon$, go to $q_{S_{02}}$. &nbsp; <em>(Slash consumed, still buffering month)</em></p>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">4</div>
                        <div class="math-step-content">
                            <p>$q_{S_{02}}$: Read '1', output '1', go to $q_{D_{02}}$. &nbsp; <em>(First day digit goes straight to output)</em></p>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">5</div>
                        <div class="math-step-content">
                            <p>$q_{D_{02}}$: Read '6', output '6.02', go to $q_F$. &nbsp; <em>(Second day digit + separator + buffered month)</em></p>
                        </div>
                    </div>
                </div>

                <div class="warning-box">
                    <div class="box-title">Buffering Costs States</div>
                    <p style="margin-bottom: 0;">
                        Notice that buffering the month requires encoding it in the state name ($q_{M_{02}}$, $q_{M_{03}}$, etc.). For a 2-digit month, we need $10 \times 10 = 100$ states just for the buffering phase. This is a general principle: <strong>every bit of lookahead or reordering costs states exponentially</strong>. This is why FSTs excel at left-to-right, streaming transformations and struggle with long-range reordering.
                    </p>
                </div>

                <!-- Section 4: Deterministic vs Non-Deterministic -->
                <h2 id="deterministic-vs-nondeterministic">Deterministic vs Non-Deterministic FSTs</h2>

                <div class="definition-box">
                    <div class="box-title">DFST vs NDFST</div>
                    <p>
                        A <strong>Deterministic FST</strong> (DFST): for each state and input symbol, there is <em>at most one</em> transition. Given an input string, the output is unique (or the input is rejected).
                    </p>
                    <p style="margin-bottom: 0;">
                        A <strong>Non-Deterministic FST</strong> (NDFST): for a state and input symbol, there may be <em>multiple</em> transitions. Given an input string, there may be <em>multiple possible outputs</em>.
                    </p>
                </div>

                <div class="note-box">
                    <div class="box-title">Non-determinism = Multiple Valid Outputs</div>
                    <p style="margin-bottom: 0;">
                        Unlike finite automata (where non-determinism doesn't add expressive power), non-deterministic FSTs are strictly more powerful than deterministic ones. A DFST computes a <em>function</em> (one output per input), while an NDFST computes a <em>relation</em> (potentially many outputs per input). Not every NDFST can be converted to a DFST.
                    </p>
                </div>

                <p><strong>Example: English Verb Past Tense</strong></p>
                <p>
                    Consider an FST for generating past tenses. Regular verbs follow simple rules ("walk" &rarr; "walked"), but irregular verbs have multiple valid forms:
                </p>

                <p>
                    Let's trace a concrete non-deterministic FST for the word "dive":
                </p>

                <div class="math-derivation">
                    <div class="math-derivation-title">Non-Deterministic FST: "dive" &rarr; "dived" or "dove"</div>

                    <div class="math-step">
                        <div class="math-step-number">1</div>
                        <div class="math-step-content">
                            <p>$q_0 \xrightarrow{d:d} q_1 \xrightarrow{i:i} q_2 \xrightarrow{v:v} q_3 \xrightarrow{e:ed} q_F$ &nbsp; <em>(Path A: regular rule, add "d")</em></p>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">2</div>
                        <div class="math-step-content">
                            <p>$q_0 \xrightarrow{d:d} q_1 \xrightarrow{i:o} q_4 \xrightarrow{v:v} q_5 \xrightarrow{e:e} q_F$ &nbsp; <em>(Path B: irregular "dove")</em></p>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">3</div>
                        <div class="math-step-content">
                            <p>Both paths reach final state $q_F$. The FST outputs: <strong>{"dived", "dove"}</strong>.</p>
                        </div>
                    </div>
                </div>

                <p>
                    The non-determinism appears at $q_1$: on input 'i', there are <strong>two transitions</strong> &mdash; one outputting 'i' (regular path) and one outputting 'o' (irregular path). A deterministic FST could only choose one. Other examples of inherent non-determinism:
                </p>
                <ul>
                    <li>"dream" &rarr; "dreamed" <em>or</em> "dreamt" (two valid past tenses)</li>
                    <li>"read" &rarr; "read" (same spelling, different pronunciation /rEd/)</li>
                    <li>"bow" &rarr; /baU/ (bend) <em>or</em> /boU/ (weapon) &mdash; same input, different meanings</li>
                </ul>

                <div class="warning-box">
                    <div class="box-title">Epsilon Transitions Can Introduce Non-Determinism</div>
                    <p style="margin-bottom: 0;">
                        Even if no state has two transitions on the same input symbol, epsilon ($\varepsilon$) transitions can create non-determinism. In state $q$, the FST can either take an $\varepsilon$-transition (consuming no input) or wait for the next input symbol. This creates ambiguity about <em>when</em> to take the epsilon transition, potentially producing different outputs. Epsilon removal algorithms can sometimes eliminate this source of non-determinism.
                    </p>
                </div>

                <!-- Section 5: Composition -->
                <h2 id="composition">Composition of FSTs</h2>

                <p>
                    The most powerful operation on FSTs is <strong>composition</strong>. If FST $T_1$ maps input to intermediate representation, and $T_2$ maps intermediate to output, then $T_1 \circ T_2$ maps input directly to output.
                </p>

                <div class="definition-box">
                    <div class="box-title">FST Composition</div>
                    <p>
                        Given FSTs $T_1: \Sigma^* \to \Gamma^*$ and $T_2: \Gamma^* \to \Delta^*$, the composition $T_1 \circ T_2$ is an FST that maps $\Sigma^* \to \Delta^*$ such that:
                    </p>
                    <div class="math-block" style="margin-bottom: 0;">
                        $$(T_1 \circ T_2)(x) = T_2(T_1(x))$$
                    </div>
                </div>

                <div class="math-derivation">
                    <div class="math-derivation-title">Composition Algorithm (Sketch)</div>

                    <div class="math-step">
                        <div class="math-step-number">1</div>
                        <div class="math-step-content">
                            <p>States of $T_1 \circ T_2$ are pairs $(q_1, q_2)$ where $q_1 \in Q_1$ and $q_2 \in Q_2$.</p>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">2</div>
                        <div class="math-step-content">
                            <p>For each transition $q_1 \xrightarrow{a:b} q_1'$ in $T_1$ and $q_2 \xrightarrow{b:c} q_2'$ in $T_2$:</p>
                            <div class="math-block">
                                $$(q_1, q_2) \xrightarrow{a:c} (q_1', q_2')$$
                            </div>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">3</div>
                        <div class="math-step-content">
                            <p>The intermediate symbol $b$ is consumed internally &mdash; it matches the output of $T_1$ with the input of $T_2$.</p>
                        </div>
                    </div>

                    <div class="math-step">
                        <div class="math-step-number">4</div>
                        <div class="math-step-content">
                            <p>Start state: $(q_{0,1}, q_{0,2})$. Final states: $F_1 \times F_2$.</p>
                        </div>
                    </div>
                </div>

                <p><strong>Example: Composition Step by Step</strong></p>
                <p>
                    Let's compose two tiny FSTs and trace every state pair:
                </p>
                <p>
                    $T_1$ (digit to English): $q_0 \xrightarrow{1:\text{one}} q_0$, $q_0 \xrightarrow{2:\text{two}} q_0$ &nbsp;(single-state FST)
                </p>
                <p>
                    $T_2$ (English to Spanish): $r_0 \xrightarrow{\text{one}:\text{uno}} r_0$, $r_0 \xrightarrow{\text{two}:\text{dos}} r_0$ &nbsp;(single-state FST)
                </p>
                <p>
                    Composing $T_1 \circ T_2$ produces: state $(q_0, r_0)$ with transitions:
                </p>
                <ul>
                    <li>$(q_0, r_0) \xrightarrow{1:\text{uno}} (q_0, r_0)$ &mdash; $T_1$ maps 1 &rarr; "one", $T_2$ maps "one" &rarr; "uno"</li>
                    <li>$(q_0, r_0) \xrightarrow{2:\text{dos}} (q_0, r_0)$ &mdash; $T_1$ maps 2 &rarr; "two", $T_2$ maps "two" &rarr; "dos"</li>
                </ul>
                <p>
                    The composed FST directly maps digits to Spanish &mdash; the English intermediate representation is eliminated. This is more efficient than running two passes and enables optimization (determinization, minimization) of the combined transducer.
                </p>

                <p><strong>Practical Example: Text Normalization Pipeline</strong></p>
                <p>
                    Real systems compose many FSTs. For text-to-speech preprocessing:
                </p>
                <ul>
                    <li>$T_1$: Expand abbreviations ("Dr." &rarr; "Doctor", "St." &rarr; "Street")</li>
                    <li>$T_2$: Expand numbers ("42" &rarr; "forty two")</li>
                    <li>$T_3$: Normalize whitespace (collapse multiple spaces)</li>
                    <li>$T_4$: Lowercase ("Doctor" &rarr; "doctor")</li>
                </ul>
                <p>
                    The composed FST $T_1 \circ T_2 \circ T_3 \circ T_4$ handles all four transformations in a single pass through the input.
                </p>

                <div class="note-box">
                    <div class="box-title">Composition Is Associative</div>
                    <p style="margin-bottom: 0;">
                        $(T_1 \circ T_2) \circ T_3 = T_1 \circ (T_2 \circ T_3)$. This means you can build complex pipelines by composing simple FSTs in any order. In speech recognition, the full decoding pipeline is a composition of 4+ transducers (acoustic model, context-dependency, pronunciation lexicon, language model).
                    </p>
                </div>

                <div class="warning-box">
                    <div class="box-title">Composition Can Blow Up</div>
                    <p style="margin-bottom: 0;">
                        If $T_1$ has $n_1$ states and $T_2$ has $n_2$ states, the composed FST can have up to $n_1 \times n_2$ states. For large transducers, this product can be enormous. In practice, many state pairs are unreachable, and applying determinization and minimization between compositions keeps sizes manageable. The order of composition matters: always compose the two smallest FSTs first.
                    </p>
                </div>

                <!-- Section 6: Regular Languages -->
                <h2 id="regular-languages">FSTs and Regular Languages</h2>

                <p>
                    FSTs operate on <strong>regular languages</strong> and compute <strong>regular relations</strong>. A regular relation is a mapping between sets of strings that can be computed by a finite-state device. This places FSTs firmly in the Chomsky hierarchy &mdash; they are less powerful than pushdown automata or Turing machines, but this limitation is also their strength.
                </p>

                <p>
                    Every regular expression can be viewed as an FSA (finite-state acceptor), and every FSA can be extended to an FST by adding output labels. Conversely, the input projection or output projection of an FST is always a regular language.
                </p>

                <div class="note-box">
                    <div class="box-title">Fundamental Limitation: FSTs Cannot Count</div>
                    <p style="margin-bottom: 0;">
                        FSTs cannot recognize or transduce patterns that require unbounded counting. The classic example: $\{a^n b^n \mid n \geq 0\}$ (equal numbers of a's and b's) is not a regular language and cannot be processed by any FST. Similarly, an FST cannot verify that parentheses are balanced or that HTML tags are properly nested. These tasks require a stack &mdash; a pushdown automaton.
                    </p>
                </div>

                <p>
                    <strong>Why can't FSTs count?</strong> Suppose we try to build an FST that checks if a string has equal numbers of a's and b's. After reading "aaa", the FST must be in a state that "remembers" the count is 3. After "aaaa", a state remembering count 4. But for arbitrary-length inputs, we'd need infinitely many states &mdash; violating the "finite" in Finite State Transducer. Any fixed FST can only count up to some bound determined by its number of states.
                </p>

                <div class="definition-box">
                    <div class="box-title">The Chomsky Hierarchy (FST Context)</div>
                    <p>
                        FSTs sit at <strong>Level 3 (Regular)</strong> of the Chomsky hierarchy:
                    </p>
                    <ul style="margin-bottom: 0;">
                        <li><strong>Level 3 &mdash; Regular:</strong> FSMs/FSTs. No memory beyond current state. Can't count.</li>
                        <li><strong>Level 2 &mdash; Context-Free:</strong> Pushdown automata. Has a stack. Can match balanced brackets.</li>
                        <li><strong>Level 1 &mdash; Context-Sensitive:</strong> Linear-bounded automata. Can handle $a^n b^n c^n$.</li>
                        <li><strong>Level 0 &mdash; Unrestricted:</strong> Turing machines. Can compute anything computable.</li>
                    </ul>
                </div>

                <p>
                    <strong>Connection to regular expressions:</strong> Any transformation that can be described as "find this pattern and replace with that" (where "pattern" is a regular expression) can be implemented as an FST. Tools like <code>sed</code> and regex-based find-and-replace are essentially FST operations. FST libraries make this connection explicit and add the ability to compose, optimize, and reason about these transformations.
                </p>

                <p>
                    <strong>Practical consequence:</strong> Most text-processing tasks involve regular patterns (dates, phone numbers, abbreviations, morphological suffixes). These are exactly where FSTs shine. When you encounter a task that requires counting, nesting, or unbounded memory &mdash; that's when you need a more powerful tool (a parser, a neural net, or a hand-written program).
                </p>

                <!-- Section 7: When to Use FSTs -->
                <h2 id="when-to-use-fsts">When to Use FSTs</h2>

                <p>
                    FSTs are not a universal tool. They excel in specific scenarios and fail in others. Knowing when to use FSTs &mdash; and when not to &mdash; is a crucial practical skill.
                </p>

                <p><strong>Use FSTs when:</strong></p>
                <ul>
                    <li><strong>You have explicit rules:</strong> The transformation can be written as a set of deterministic rules (e.g., text normalization, date formatting).</li>
                    <li><strong>The input has known structure:</strong> The patterns are regular and finite (e.g., phone numbers, postal codes, morphological paradigms).</li>
                    <li><strong>Interpretability matters:</strong> You need to understand, debug, and explain every transformation the system makes.</li>
                    <li><strong>You have little or no training data:</strong> FSTs encode expert knowledge directly &mdash; no data needed.</li>
                    <li><strong>You need guaranteed behavior:</strong> FSTs never hallucinate, never produce unexpected outputs outside their defined rules.</li>
                </ul>

                <p><strong>Do NOT use FSTs when:</strong></p>
                <ul>
                    <li><strong>You need to learn from data:</strong> FSTs don't learn &mdash; they execute rules. If you don't know the rules, you can't build the FST.</li>
                    <li><strong>Long-range context is needed:</strong> FSTs have finite memory (bounded by the number of states). They can't handle dependencies that span arbitrary distances.</li>
                    <li><strong>The transformation is ambiguous and context-dependent:</strong> "Read" can be /riyd/ or /rEd/ depending on sentence context &mdash; an FST alone can't resolve this.</li>
                    <li><strong>The rules change frequently:</strong> If the transformation rules evolve with data, a learned model adapts automatically while an FST needs manual updates.</li>
                </ul>

                <table style="width: 100%; border-collapse: collapse; margin: 1.5rem 0;">
                    <thead>
                        <tr style="border-bottom: 2px solid var(--color-border);">
                            <th style="text-align: left; padding: 0.75rem;">Task</th>
                            <th style="text-align: left; padding: 0.75rem;">FST?</th>
                            <th style="text-align: left; padding: 0.75rem;">Why</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">Date format conversion</td>
                            <td style="padding: 0.75rem;">Yes</td>
                            <td style="padding: 0.75rem;">Fixed rules, known structure, no data needed</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">Expand abbreviations</td>
                            <td style="padding: 0.75rem;">Yes</td>
                            <td style="padding: 0.75rem;">Dictionary lookup, deterministic</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">Turkish morphology</td>
                            <td style="padding: 0.75rem;">Yes</td>
                            <td style="padding: 0.75rem;">Regular suffixation, well-studied rules</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">Sentiment analysis</td>
                            <td style="padding: 0.75rem;">No</td>
                            <td style="padding: 0.75rem;">Requires understanding meaning, context</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-border);">
                            <td style="padding: 0.75rem;">Machine translation</td>
                            <td style="padding: 0.75rem;">Partial</td>
                            <td style="padding: 0.75rem;">FST for preprocessing, neural for core translation</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem;">Code compilation</td>
                            <td style="padding: 0.75rem;">No</td>
                            <td style="padding: 0.75rem;">Needs nested scoping (context-free), not regular</td>
                        </tr>
                    </tbody>
                </table>

                <div class="warning-box">
                    <div class="box-title">FSTs vs Neural Networks</div>
                    <p>
                        FSTs and neural networks are complementary, not competing:
                    </p>
                    <ul style="margin-bottom: 0;">
                        <li><strong>FSTs:</strong> Guaranteed behavior, interpretable, zero data required, fast at runtime, but require manual rule engineering.</li>
                        <li><strong>Neural nets:</strong> Learn from data, handle ambiguity, flexible, but need training data, can hallucinate, and are harder to debug.</li>
                        <li><strong>Best practice:</strong> Combine both. Use FSTs for preprocessing/normalization (where rules are known) and neural nets for the core task (where learning is needed). We explore this hybrid approach in Tutorial 24.</li>
                    </ul>
                </div>

                <!-- Section 8: Summary -->
                <h2 id="summary">Summary</h2>

                <p><strong>Key takeaways:</strong></p>
                <ol>
                    <li><strong>FSTs are sequence transformers:</strong> They read input symbols and produce output symbols according to state-transition rules.</li>
                    <li><strong>Formal definition:</strong> A 6-tuple $(Q, \Sigma, \Gamma, \delta, q_0, F)$ &mdash; states, input alphabet, output alphabet, transitions, start state, final states.</li>
                    <li><strong>Deterministic vs non-deterministic:</strong> DFSTs compute functions (unique output), NDFSTs compute relations (multiple possible outputs).</li>
                    <li><strong>Composition is key:</strong> Complex transformations are built by composing simple FSTs: $T_1 \circ T_2$.</li>
                    <li><strong>Regular languages:</strong> FSTs compute regular relations &mdash; powerful for pattern-based transformations, but cannot count.</li>
                    <li><strong>Know the limits:</strong> Use FSTs for rule-based, interpretable transformations. Use neural nets for learned, context-dependent tasks.</li>
                </ol>

                <p>
                    In the next tutorial, we add <strong>weights</strong> to FSTs, enabling them to rank alternative outputs and model probabilistic transformations &mdash; the key to speech recognition and other applications.
                </p>

                <!-- Navigation -->
                <div class="tutorial-footer-summary" style="margin: 3rem 0; padding: 2rem; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3b82f6;">
                    <h1>20. FST Fundamentals</h1>
                    <p class="lead">
                        Finite State Machines and Transducers: the foundation for deterministic, interpretable sequence transformations.
                    </p>
                </div>
                <div class="tutorial-nav">
                    <a href="../18-designing-biases/index.html" class="tutorial-nav-link prev">
                        <span class="nav-label">Previous</span>
                        <span class="nav-title">&larr; Designing Biases</span>
                    </a>
                    <a href="../20-weighted-fsts/index.html" class="tutorial-nav-link next">
                        <span class="nav-label">Next</span>
                        <span class="nav-title">Weighted FSTs &rarr;</span>
                    </a>
                </div>

            </article>

            <!-- ==================== CODE TAB ==================== -->
            <article class="article-content" id="code" style="display: none;">
                <h2>Python Code Examples</h2>
                <p>Three code examples: building an FST from scratch, thinking about regex as FSTs, and tracing FST execution step by step.</p>

                <!-- Code Example 1 -->
                <h3>1. Manual FST Construction: Lowercase Converter</h3>
                <p>
                    A simple Python class implementing an FST from scratch. This FST converts lowercase ASCII letters to uppercase.
                </p>

                <div class="code-block">
                    <div class="code-block-header">
                        <span class="code-block-lang">python</span>
                        <button class="code-block-copy">Copy</button>
                    </div>
                    <pre><code class="language-python">class FST:
    """A simple Finite State Transducer implementation.

    Handles non-determinism via BFS and guards against
    epsilon cycles with a visited-state check.
    """

    def __init__(self):
        self.transitions = {}  # (state, input) -> [(output, next_state)]
        self.start_state = 'q0'
        self.final_states = set()

    def add_transition(self, state, input_sym, output_sym, next_state):
        """Add a transition: state --input:output--> next_state.
        Use input_sym='' for epsilon (no input consumed).
        """
        key = (state, input_sym)
        if key not in self.transitions:
            self.transitions[key] = []
        self.transitions[key].append((output_sym, next_state))

    def add_final_state(self, state):
        self.final_states.add(state)

    def _epsilon_closure(self, state, output_prefix):
        """Compute all states reachable via epsilon transitions,
        accumulating output along the way. Handles cycles safely."""
        result = [(state, output_prefix)]
        visited = {state}
        queue = [(state, output_prefix)]

        while queue:
            s, out = queue.pop(0)
            key = (s, '')
            if key in self.transitions:
                for out_sym, next_state in self.transitions[key]:
                    if next_state not in visited:
                        visited.add(next_state)
                        new_out = out + out_sym
                        result.append((next_state, new_out))
                        queue.append((next_state, new_out))
        return result

    def transduce(self, input_string):
        """Apply the FST to an input string. Returns list of possible outputs.
        Uses BFS to explore all non-deterministic paths.
        """
        # Each entry: (current_state, input_position, output_so_far)
        # Start with epsilon closure of start state
        active = [(s, 0, out) for s, out in
                  self._epsilon_closure(self.start_state, '')]
        results = []

        while active:
            state, pos, output = active.pop(0)

            if pos == len(input_string):
                if state in self.final_states:
                    results.append(output)
                continue

            # Try matching current input symbol
            key = (state, input_string[pos])
            if key in self.transitions:
                for out_sym, next_state in self.transitions[key]:
                    # After consuming input, expand epsilon closure
                    for s2, out2 in self._epsilon_closure(
                            next_state, output + out_sym):
                        active.append((s2, pos + 1, out2))

        return results


# Build a lowercase-to-uppercase FST
fst = FST()
fst.add_final_state('q0')

for c in 'abcdefghijklmnopqrstuvwxyz':
    fst.add_transition('q0', c, c.upper(), 'q0')

# Also pass through non-letter characters unchanged
for c in ' .,!?0123456789':
    fst.add_transition('q0', c, c, 'q0')

# Test
test_inputs = ['hello', 'world', 'hello world!', 'test 123']
print("Lowercase-to-Uppercase FST")
print("=" * 40)
for inp in test_inputs:
    outputs = fst.transduce(inp)
    print(f"  '{inp}' -> {outputs}")

# Build a more interesting FST: simple pluralization
plural_fst = FST()
plural_fst.add_final_state('done')

# For words ending in 's', 'x', 'z': add 'es'
# For other words: add 's'
# Simplified: read characters, at end decide suffix

# State 'reading': accumulate the word
# When we hit end-of-input, check last character
for c in 'abcdefghijklmnopqrstuvwxyz':
    if c in 'sxz':
        plural_fst.add_transition('reading', c, c, 'needs_es')
    else:
        plural_fst.add_transition('reading', c, c, 'reading')

# From needs_es: if another letter follows, it's not the end
for c in 'abcdefghijklmnopqrstuvwxyz':
    if c in 'sxz':
        plural_fst.add_transition('needs_es', c, c, 'needs_es')
    else:
        plural_fst.add_transition('needs_es', c, c, 'reading')

# Epsilon transitions at end of input
plural_fst.add_transition('reading', '', 's', 'done')
plural_fst.add_transition('needs_es', '', 'es', 'done')

plural_fst.start_state = 'reading'

print("\nSimple Pluralization FST")
print("=" * 40)
for word in ['cat', 'dog', 'box', 'bus', 'quiz', 'tree']:
    outputs = plural_fst.transduce(word)
    print(f"  '{word}' -> {outputs}")</code></pre>
                </div>

                <!-- Code Example 2 -->
                <h3>2. Regex to FST: Thinking About Patterns as Transducers</h3>
                <p>
                    Every regex find-and-replace can be thought of as an FST. Here we show how to think about regex patterns in FST terms and build a simple email domain extractor.
                </p>

                <div class="code-block">
                    <div class="code-block-header">
                        <span class="code-block-lang">python</span>
                        <button class="code-block-copy">Copy</button>
                    </div>
                    <pre><code class="language-python">import re

# Regex approach: extract domain from email
emails = ['user@gmail.com', 'admin@company.org', 'test@sub.domain.co.uk']
print("Regex vs FST Thinking")
print("=" * 50)

# Regex way
print("\n1. Regex approach:")
for email in emails:
    match = re.search(r'@(.+)$', email)
    if match:
        print(f"   {email} -> domain: {match.group(1)}")

# FST way: think of it as a state machine
# State 'before_at': consume input, output nothing
# State 'after_at': consume input, output the character
print("\n2. FST approach (same result, different thinking):")

class EmailDomainFST:
    """FST that extracts domain from email address."""

    def transduce(self, email):
        state = 'before_at'
        output = ''

        for char in email:
            if state == 'before_at':
                if char == '@':
                    state = 'after_at'
                    # input '@', output nothing (epsilon)
                else:
                    pass  # input char, output nothing
            elif state == 'after_at':
                output += char  # input char, output char

        return output if state == 'after_at' else None

fst = EmailDomainFST()
for email in emails:
    print(f"   {email} -> domain: {fst.transduce(email)}")

# The deeper point: regex operations ARE FST operations
print("\n3. Regex operations as FST operations:")
operations = [
    ("Concatenation", "ab", "Match 'a' then 'b'", "Sequential transitions"),
    ("Alternation", "a|b", "Match 'a' or 'b'", "Non-deterministic branch"),
    ("Kleene star", "a*", "Zero or more 'a's", "Self-loop on state"),
    ("Character class", "[a-z]", "Any lowercase", "26 parallel transitions"),
]

print(f"   {'Regex Op':<18} {'Regex':<10} {'Meaning':<25} {'FST Equivalent'}")
print(f"   {'-'*18} {'-'*10} {'-'*25} {'-'*25}")
for op, regex, meaning, fst_equiv in operations:
    print(f"   {op:<18} {regex:<10} {meaning:<25} {fst_equiv}")

print("\nKey insight: Regex engines are FST engines under the hood.")
print("FST libraries give you composition, optimization, and formal")
print("reasoning that plain regex cannot provide.")</code></pre>
                </div>

                <!-- Code Example 3 -->
                <h3>3. Trace Execution: Step-by-Step State Transitions</h3>
                <p>
                    A verbose FST that prints every state transition, showing exactly how it processes input. This is invaluable for debugging FSTs.
                </p>

                <div class="code-block">
                    <div class="code-block-header">
                        <span class="code-block-lang">python</span>
                        <button class="code-block-copy">Copy</button>
                    </div>
                    <pre><code class="language-python">class TracingFST:
    """FST that prints detailed execution trace."""

    def __init__(self, name="FST"):
        self.name = name
        self.transitions = {}
        self.start_state = 'q0'
        self.final_states = set()

    def add_transition(self, state, input_sym, output_sym, next_state):
        key = (state, input_sym)
        if key not in self.transitions:
            self.transitions[key] = []
        self.transitions[key].append((output_sym, next_state))

    def add_final_state(self, state):
        self.final_states.add(state)

    def transduce(self, input_string, verbose=True):
        if verbose:
            print(f"\n{'='*60}")
            print(f"  {self.name}: Processing '{input_string}'")
            print(f"{'='*60}")

        state = self.start_state
        output = ''

        if verbose:
            print(f"  Start: state={state}")

        for i, char in enumerate(input_string):
            key = (state, char)
            if key not in self.transitions:
                if verbose:
                    print(f"  Step {i+1}: state={state}, input='{char}' -> NO TRANSITION (rejected)")
                return None

            # Take first transition (deterministic)
            out_sym, next_state = self.transitions[key][0]

            if verbose:
                eps_in = repr(char)
                eps_out = repr(out_sym) if out_sym else 'e'
                print(f"  Step {i+1}: state={state}, input={eps_in}, "
                      f"output={eps_out}, -> state={next_state}")

            output += out_sym
            state = next_state

        if state in self.final_states:
            if verbose:
                print(f"  End: state={state} (FINAL STATE)")
                print(f"  Result: '{input_string}' -> '{output}'")
            return output
        else:
            if verbose:
                print(f"  End: state={state} (NOT a final state - rejected)")
            return None


# Build a date format converter: MM/DD -> DD.MM
date_fst = TracingFST("Date Converter (MM/DD -> DD.MM)")

digits = '0123456789'

# Read first digit of month -> store in state name
for d1 in digits:
    date_fst.add_transition('q0', d1, '', f'M1_{d1}')

# Read second digit of month
for d1 in digits:
    for d2 in digits:
        date_fst.add_transition(f'M1_{d1}', d2, '', f'M2_{d1}{d2}')

# Read slash
for d1 in digits:
    for d2 in digits:
        date_fst.add_transition(f'M2_{d1}{d2}', '/', '', f'slash_{d1}{d2}')

# Read first digit of day, output it
for m1 in digits:
    for m2 in digits:
        for d1 in digits:
            date_fst.add_transition(f'slash_{m1}{m2}', d1, d1, f'D1_{m1}{m2}')

# Read second digit of day, output it + '.' + month
for m1 in digits:
    for m2 in digits:
        for d2 in digits:
            date_fst.add_transition(f'D1_{m1}{m2}', d2, f'{d2}.{m1}{m2}', 'done')

date_fst.add_final_state('done')

# Test
date_fst.transduce('02/16')
date_fst.transduce('12/25')
date_fst.transduce('07/04')

print("\nThis trace shows every state transition, making it")
print("easy to debug when an FST produces unexpected output.")</code></pre>
                </div>

            </article>

            <!-- ==================== EXERCISES TAB ==================== -->
            <article class="article-content" id="exercises" style="display: none;">
                <h2>Exercises</h2>
                <p>Test your understanding of FST fundamentals. Exercises range from drawing FST diagrams to proving theoretical properties and designing transducers for practical tasks.</p>

                <div class="exercise-list">

                    <!-- Easy -->
                    <h3 style="margin-top: 1rem; border-bottom: 1px solid var(--color-border); padding-bottom: 0.5rem;">Easy</h3>

                    <!-- Exercise 1 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">1. Draw an FST for Date Formats</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>Design an FST that converts dates from "YYYY-MM-DD" format to "DD/MM/YYYY" format. List all states and transitions. You may assume the input is always valid.</p>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p><strong>States:</strong> We need to buffer the year (4 digits) and month (2 digits) before we can output them.</p>
                                <p>Let $Y = y_1 y_2 y_3 y_4$ be the year digits and $M = m_1 m_2$ be the month digits.</p>
                                <ul>
                                    <li>$q_0$: Start. Read $y_1$, output $\varepsilon$, go to $q_1(y_1)$.</li>
                                    <li>$q_1(y_1)$: Read $y_2$, output $\varepsilon$, buffer year digits.</li>
                                    <li>... (continue buffering $y_3, y_4$)</li>
                                    <li>After reading '-': buffer month digits $m_1, m_2$.</li>
                                    <li>After reading second '-': read day digits $d_1, d_2$.</li>
                                    <li>At end: output "$d_1 d_2 / m_1 m_2 / y_1 y_2 y_3 y_4$".</li>
                                </ul>
                                <p>The key insight: the FST must buffer the entire year and month before it can begin outputting, because the output starts with the day (which appears last in the input). This requires $10^6$ states (one for each combination of 4 year digits + 2 month digits) in the worst case, though in practice many states can be shared.</p>
                                <p>A simpler approach: use two composed FSTs. $T_1$ reverses the field order (YYYY-MM-DD &rarr; DD-MM-YYYY) and $T_2$ replaces '-' with '/'.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Exercise 2 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">2. Trace FST Execution</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>Given the following FST transitions, trace the execution on input "abba":</p>
                            <ul>
                                <li>$q_0 \xrightarrow{a:x} q_1$</li>
                                <li>$q_1 \xrightarrow{b:y} q_1$</li>
                                <li>$q_1 \xrightarrow{a:x} q_2$</li>
                                <li>$q_0 \xrightarrow{b:y} q_0$</li>
                                <li>Final states: $\{q_2\}$</li>
                            </ul>
                            <p>What is the output? Is the FST deterministic?</p>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p><strong>Trace on "abba":</strong></p>
                                <ol>
                                    <li>State $q_0$, read 'a', output 'x', go to $q_1$.</li>
                                    <li>State $q_1$, read 'b', output 'y', stay in $q_1$.</li>
                                    <li>State $q_1$, read 'b', output 'y', stay in $q_1$.</li>
                                    <li>State $q_1$, read 'a', output 'x', go to $q_2$.</li>
                                </ol>
                                <p>$q_2$ is a final state, so the input is accepted. <strong>Output: "xyyx"</strong>.</p>
                                <p><strong>Is it deterministic?</strong> We need to check if any state has multiple transitions on the same input. State $q_1$ has transitions on both 'b' (to $q_1$) and 'a' (to $q_2$), but these are on <em>different</em> input symbols, so there's no conflict. State $q_0$ has 'a' &rarr; $q_1$ and 'b' &rarr; $q_0$, again different symbols. <strong>Yes, the FST is deterministic.</strong></p>
                            </div>
                        </div>
                    </div>

                    <!-- Exercise 3 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">3. Identify Determinism</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>For each FST, state whether it is deterministic or non-deterministic, and explain why:</p>
                            <ol type="a">
                                <li>$q_0 \xrightarrow{a:x} q_1$, $q_0 \xrightarrow{a:y} q_2$</li>
                                <li>$q_0 \xrightarrow{a:x} q_1$, $q_0 \xrightarrow{b:y} q_1$</li>
                                <li>$q_0 \xrightarrow{a:x} q_1$, $q_0 \xrightarrow{\varepsilon:z} q_2$, $q_2 \xrightarrow{a:y} q_1$</li>
                            </ol>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p><strong>(a) Non-deterministic.</strong> State $q_0$ has two transitions on the same input 'a' but with different outputs (x vs y) and different next states ($q_1$ vs $q_2$). Given input 'a', the FST could produce either 'x' or 'y'.</p>
                                <p><strong>(b) Deterministic.</strong> State $q_0$ has transitions on different input symbols ('a' and 'b'). For any given input symbol, there is exactly one transition. The fact that both go to $q_1$ doesn't matter.</p>
                                <p><strong>(c) Non-deterministic.</strong> In state $q_0$ with input 'a', the FST can either: (1) take the $a:x$ transition directly to $q_1$, or (2) take the $\varepsilon:z$ transition to $q_2$ and then the $a:y$ transition to $q_1$. This gives outputs 'x' vs 'zy' for the same input 'a'. Epsilon transitions can introduce non-determinism.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Medium -->
                    <h3 style="margin-top: 2rem; border-bottom: 1px solid var(--color-border); padding-bottom: 0.5rem;">Medium</h3>

                    <!-- Exercise 4 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">4. Design an FST for English Pluralization</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>Design an FST that pluralizes English nouns following these rules:</p>
                            <ul>
                                <li>Words ending in s, x, z, ch, sh: add "es" (box &rarr; boxes, dish &rarr; dishes)</li>
                                <li>Words ending in consonant + y: change y to "ies" (city &rarr; cities)</li>
                                <li>All other words: add "s" (cat &rarr; cats)</li>
                            </ul>
                            <p>You don't need to handle every edge case &mdash; focus on the state machine design for these three rules.</p>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p><strong>Key states:</strong></p>
                                <ul>
                                    <li><code>normal</code>: reading characters, last char was not special</li>
                                    <li><code>after_s/x/z</code>: last char was s, x, or z</li>
                                    <li><code>after_c</code>: last char was 'c' (checking for 'ch')</li>
                                    <li><code>after_s_letter</code>: last char was 's' (checking for 'sh')</li>
                                    <li><code>after_ch/sh</code>: last two chars were 'ch' or 'sh'</li>
                                    <li><code>after_consonant</code>: last char was a consonant (checking for 'y')</li>
                                    <li><code>after_consonant_y</code>: pattern consonant+y detected</li>
                                </ul>
                                <p><strong>End-of-input transitions (epsilon):</strong></p>
                                <ul>
                                    <li>From <code>after_s/x/z</code> or <code>after_ch/sh</code>: output "es"</li>
                                    <li>From <code>after_consonant_y</code>: delete the 'y' (don't output it) and output "ies"</li>
                                    <li>From <code>normal</code> or <code>after_consonant</code>: output "s"</li>
                                </ul>
                                <p>The tricky part is the consonant+y rule: the FST must delay outputting 'y' until it knows whether the word ends there. This is handled by buffering: in the <code>after_consonant</code> state, if we see 'y', we don't output it immediately but move to <code>after_consonant_y</code>. If more characters follow, we output the buffered 'y' and continue. If the word ends, we output "ies" instead.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Exercise 5 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">5. Prove Composition Associativity</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>Prove that FST composition is associative: $(T_1 \circ T_2) \circ T_3 = T_1 \circ (T_2 \circ T_3)$.</p>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p>Let $T_1: \Sigma^* \to \Gamma^*$, $T_2: \Gamma^* \to \Delta^*$, and $T_3: \Delta^* \to \Omega^*$.</p>
                                <p>For any input $x \in \Sigma^*$:</p>
                                <div class="math-block">
                                    $$((T_1 \circ T_2) \circ T_3)(x) = T_3((T_1 \circ T_2)(x)) = T_3(T_2(T_1(x)))$$
                                </div>
                                <div class="math-block">
                                    $$(T_1 \circ (T_2 \circ T_3))(x) = (T_2 \circ T_3)(T_1(x)) = T_3(T_2(T_1(x)))$$
                                </div>
                                <p>Both expressions equal $T_3(T_2(T_1(x)))$ for all $x$. Since the relations computed by both composed FSTs are identical, $(T_1 \circ T_2) \circ T_3 = T_1 \circ (T_2 \circ T_3)$.</p>
                                <p><strong>Note:</strong> This proof works at the relation level. At the implementation level, the resulting FSTs may have different numbers of states, but they compute the same relation.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Exercise 6 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">6. Find a Non-Regular Transformation</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>Give three examples of string transformations that <strong>cannot</strong> be implemented by any FST. For each, explain why the transformation is non-regular.</p>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p><strong>1. String reversal:</strong> $f(\text{"abc"}) = \text{"cba"}$. An FST would need to buffer the entire input before producing output (it needs to output the last character first). For arbitrary-length input, this requires unbounded memory &mdash; more states than any finite machine can have.</p>
                                <p><strong>2. String duplication:</strong> $f(w) = ww$ (e.g., "abc" &rarr; "abcabc"). After outputting the string once, the FST would need to "remember" the entire input to output it again. This requires unbounded memory.</p>
                                <p><strong>3. Balanced bracket generation:</strong> $f(a^n) = (^n )^n$ (e.g., "aaa" &rarr; "((()))"). The FST needs to count the a's to produce matching brackets. Since FSTs can't count beyond a fixed bound, this is impossible for arbitrary $n$.</p>
                                <p><strong>Common theme:</strong> All three require the FST to "remember" an unbounded amount of information about the input. FSTs have finite memory (bounded by $|Q|$), so any transformation requiring memory that grows with input length is impossible.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Exercise 7 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">7. Convert Regex to FST</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>Convert the following regex substitution into an FST (describe states and transitions):</p>
                            <p><code>s/colou?r/color/g</code> (replace "colour" or "color" with "color")</p>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p><strong>States and transitions:</strong></p>
                                <ul>
                                    <li>$q_0$ (start): For any char not 'c', output it and stay. On 'c', output nothing, go to $q_1$.</li>
                                    <li>$q_1$: On 'o', go to $q_2$. On anything else, output buffered 'c' + current char, go to $q_0$.</li>
                                    <li>$q_2$: On 'l', go to $q_3$. Otherwise, output "co" + current char, go to $q_0$.</li>
                                    <li>$q_3$: On 'o', go to $q_4$. Otherwise, output "col" + current char, go to $q_0$.</li>
                                    <li>$q_4$: On 'r', output "color", go to $q_0$ (matched "color"). On 'u', go to $q_5$. Otherwise, output "colo" + current char, go to $q_0$.</li>
                                    <li>$q_5$: On 'r', output "color", go to $q_0$ (matched "colour"). Otherwise, output "colou" + current char, go to $q_0$.</li>
                                </ul>
                                <p>$q_0$ is both start and final state. The FST passes through all non-matching text unchanged and replaces both "color" and "colour" with "color".</p>
                            </div>
                        </div>
                    </div>

                    <!-- Hard -->
                    <h3 style="margin-top: 2rem; border-bottom: 1px solid var(--color-border); padding-bottom: 0.5rem;">Hard</h3>

                    <!-- Exercise 8 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">8. Roman Numeral Addition FST</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>Design an FST (or argue why composition of FSTs is needed) that takes a Roman numeral as input and outputs its value incremented by 1. For example: "III" &rarr; "IV", "IV" &rarr; "V", "IX" &rarr; "X".</p>
                            <p>You may limit the input range to 1-20.</p>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p><strong>Approach:</strong> Since the range is finite (1-20), we can build a direct lookup FST. But the interesting insight is about <em>why this is hard in general</em>.</p>
                                <p><strong>For the bounded case (1-20):</strong> The simplest approach is composition of two FSTs:</p>
                                <ol>
                                    <li>$T_1$: Roman &rarr; decimal (e.g., "XIV" &rarr; "14")</li>
                                    <li>$T_2$: Increment decimal (e.g., "14" &rarr; "15")</li>
                                    <li>$T_3$: Decimal &rarr; Roman (e.g., "15" &rarr; "XV")</li>
                                </ol>
                                <p>The composed FST $T_1 \circ T_2 \circ T_3$ performs the addition.</p>
                                <p><strong>Why single-FST is harder:</strong> Roman numeral arithmetic involves subtractive notation (IV = 4, IX = 9) which makes the mapping non-trivial. An FST doing this directly would need states encoding "what Roman numeral have I seen so far" &mdash; feasible for bounded input but grows rapidly.</p>
                                <p><strong>For unbounded input:</strong> Roman numeral addition is actually beyond regular relations if we require arbitrary precision, since it requires carry propagation (a form of counting). However, for any fixed bound, it can be done with a finite (but large) FST.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Exercise 9 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">9. Minimize FST States</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>Consider an FST with these transitions (all states are final):</p>
                            <ul>
                                <li>$q_0 \xrightarrow{a:x} q_1$, $q_0 \xrightarrow{b:y} q_2$</li>
                                <li>$q_1 \xrightarrow{a:x} q_3$, $q_1 \xrightarrow{b:y} q_4$</li>
                                <li>$q_2 \xrightarrow{a:x} q_5$, $q_2 \xrightarrow{b:y} q_6$</li>
                                <li>$q_3, q_4, q_5, q_6$ have no outgoing transitions</li>
                            </ul>
                            <p>Can this FST be minimized? If so, give the minimal FST.</p>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p><strong>Yes, it can be minimized.</strong></p>
                                <p>States $q_3, q_4, q_5, q_6$ are all equivalent: they are all final states with no outgoing transitions. They can be merged into a single state $q_T$ (terminal).</p>
                                <p>After merging: $q_1$ has transitions $a:x \to q_T$ and $b:y \to q_T$, and $q_2$ has transitions $a:x \to q_T$ and $b:y \to q_T$. Since $q_1$ and $q_2$ have identical transitions (same input:output labels and same destination), they are also equivalent and can be merged into $q_M$.</p>
                                <p><strong>Minimal FST:</strong></p>
                                <ul>
                                    <li>$q_0 \xrightarrow{a:x} q_M$, $q_0 \xrightarrow{b:y} q_M$</li>
                                    <li>$q_M \xrightarrow{a:x} q_T$, $q_M \xrightarrow{b:y} q_T$</li>
                                    <li>All states final, $q_T$ has no outgoing transitions.</li>
                                </ul>
                                <p>We reduced from 7 states to 3 states. The minimized FST computes the same relation.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Exercise 10 -->
                    <div class="exercise-item">
                        <div class="exercise-header">
                            <span class="exercise-title">10. Composition Complexity Analysis</span>
                            <span class="exercise-toggle">&darr;</span>
                        </div>
                        <div class="exercise-body">
                            <p>If FST $T_1$ has $n_1$ states and $T_2$ has $n_2$ states:</p>
                            <ol type="a">
                                <li>What is the maximum number of states in $T_1 \circ T_2$?</li>
                                <li>Give an example where the composed FST actually has $n_1 \times n_2$ states (composition blowup).</li>
                                <li>Under what conditions is the composed FST much smaller than $n_1 \times n_2$?</li>
                            </ol>
                            <button class="btn btn-sm solution-toggle">Show Solution</button>
                            <div class="solution-content">
                                <p><strong>(a)</strong> The maximum number of states is $O(n_1 \times n_2)$, since states of the composed FST are pairs $(q_1, q_2)$. With epsilon transitions, the bound can be $O(n_1 \times n_2 \times |\Gamma|)$ where $|\Gamma|$ is the intermediate alphabet size, but in practice the product bound is the key one.</p>
                                <p><strong>(b)</strong> Example of full blowup: Let $T_1$ have states $\{s_0, s_1, \ldots, s_{n-1}\}$ cycling through each on every input, and $T_2$ have states $\{t_0, t_1, \ldots, t_{m-1}\}$ cycling independently. If the output alphabet of $T_1$ matches the input alphabet of $T_2$ such that every pair $(s_i, t_j)$ is reachable, the composed FST has $n \times m$ states.</p>
                                <p><strong>(c)</strong> The composed FST is much smaller when:</p>
                                <ul>
                                    <li>The output alphabet of $T_1$ is small (fewer matching transitions).</li>
                                    <li>Many state pairs are unreachable (the composed FST is sparse).</li>
                                    <li>The FSTs have similar structure (e.g., both are left-to-right with limited lookahead).</li>
                                    <li>After composition, the FST can be minimized, potentially reducing states dramatically.</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                </div>
            </article>

        </main>

        <!-- TOC (Right Side) -->
        <aside class="toc-container">
            <h4 class="toc-title">Contents</h4>
            <nav class="toc-list">
                <a href="#what-are-fsts" class="toc-link">What Are FSTs?</a>
                <a href="#formal-definition" class="toc-link">Formal Definition</a>
                <a href="#simple-examples" class="toc-link">Simple FST Examples</a>
                <a href="#deterministic-vs-nondeterministic" class="toc-link">Deterministic vs Non-Deterministic</a>
                <a href="#composition" class="toc-link">Composition</a>
                <a href="#regular-languages" class="toc-link">FSTs and Regular Languages</a>
                <a href="#when-to-use-fsts" class="toc-link">When to Use FSTs</a>
                <a href="#summary" class="toc-link">Summary</a>
            </nav>
        </aside>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <span class="logo-symbol">&nabla;</span>
                    <span>ML Fundamentals</span>
                </div>
                <p class="footer-tagline">Deep understanding through first principles.</p>
            </div>
            <div class="footer-links">
                <a href="../../../index.html">Home</a>
                <a href="https://github.com/ml-entropy/ml-entropy.github.io" target="_blank">GitHub</a>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="../../../js/main.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            // KaTeX Rendering
            if (typeof renderMathInElement === 'function') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }

            // Tab Switching Logic
            const tabs = document.querySelectorAll('.tutorial-tab');
            const articles = document.querySelectorAll('.article-content');

            function switchTab(targetId) {
                if (!targetId || targetId === '#') targetId = '#theory';

                tabs.forEach(tab => {
                    if (tab.getAttribute('href') === targetId) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });

                articles.forEach(article => {
                    const articleId = '#' + article.id;
                    if (articleId === targetId) {
                        article.style.display = 'block';
                    } else {
                        article.style.display = 'none';
                    }
                });

                if (typeof renderMathInElement === 'function') {
                    renderMathInElement(document.body, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false},
                            {left: '\\[', right: '\\]', display: true},
                            {left: '\\(', right: '\\)', display: false}
                        ],
                        throwOnError: false
                    });
                }

                const toc = document.querySelector('.toc-container');
                if (toc) {
                    if (targetId === '#theory') {
                        toc.style.display = 'block';
                        setTimeout(() => toc.classList.add('visible'), 100);
                    } else {
                        toc.classList.remove('visible');
                        setTimeout(() => toc.style.display = 'none', 300);
                    }
                }
            }

            tabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = tab.getAttribute('href');
                    history.pushState(null, null, targetId);
                    switchTab(targetId);
                });
            });

            window.addEventListener('popstate', () => {
                switchTab(window.location.hash);
            });

            switchTab(window.location.hash);
        });
    </script>
</body>
</html>
